# Belady现象_LRU_FIFO_Clock的比较



## Belady 现象

在采用 FIFO 算法的时候，有时会出现分配的物理页面数增加，但是缺页率反而提高的异常现象

### 现象的原因

FIFO 算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的（即替换较少使用的页面），因此，被它置换出去的页面并不一定是进程不会访问的页面

## LRU,FIFO,Clock 算法的比较

* LRU 算法和 FIFO 算法本质上都是**先进先出的思路**，只不过 LRU 是针对页面的<font color=red>最近访问时间来进行排序</font>，所以需要在每一次页面访问的时候进行动态的调整各个页面之间的先后的顺序（页面的最近访问时间会发生变化）；而 FIFO 是针对页面<font color=red>进入内存的时间来进行排序</font>，这个时间是固定不变的，所以各个页面之间的先后的顺序是固定的。如果一个页面在进入内存后没有被访问，那么它的最近访问时间就是它进入内存的时间。换句话说，如果内存当中的所有的页面都未被访问过，那么 LRU 算法就退化为 FIFO 算法。

* 如果程序本身没有局部性的特征，那么 LRU,FIFO 算法的相互的比较就没有什么意义了
* Clock 算法是 LRU 算法的一种逼近，只是 Clock 算法无法知道页的具体的访问时间先后关系（Clock 只有两个bit 来表达页的访问情况）
* LRU 算法性能较好，但是系统的开销比较的大；FIFO 算法的系统开销比较的小，但是可能出现 Belady 现象。因此，折衷的办法就是 Clock 算法，~~~在每一次页面访问时，它不必去动态的调整该页面在 链表中的位置，而是仅仅做一个标记，然后等到发生了缺页中断的时候，再把它移动到链表的尾部~~~。对于内存当中那些未被访问的页面，Clock 算法的表现和 LRU 算法一样好；而对于那些曾经被访问过的页面，它不能像 LRU 算法那样，记住它们的准确的位置。