# 禁用硬件中断

实现互斥的方法

* 禁用硬件中断
* 软件方法
* 更高级的抽象



## 屏蔽硬件中断

进入临界区

* 禁用中断

离开临界区

* 开启中断

> 操作系统在进行进程的调度的时候，需要时钟中断信号，在时间片内执行某个 进程，在时间片结束的时候，时钟中断信号会告知操作系统可以进行进程的切换了
>
> 如果**我们在进入临界区的时候，屏蔽中断的话，那么操作系统就不会进行进程的切换了**。
>
> 一旦中断被禁止，线程就不能被操作系统终止了，可能导致其他的线程处在饥饿状态
>
> 进程在临界区执行的时间长短是不确定的，执行时间过长，**会造成整个操作系统的严重卡顿**
>
> 中断一旦被屏蔽，除了时钟的中断，其他的外设的中断也会被屏蔽，导致了键盘，鼠标，网卡等外设的中断得不到处理
>
> 在多核心 CPU 上这种方法被限制，每个 CPU 有自己独立的中断处理过程



# 基于软件的方式解决

## 方法1 

```c++
turn = i; // 表示下一个谁进入临界区
do {
    while(turn != i);
    critical section;
    turn = j; // 表示下一个谁可以进入临界区
    reminder section;
}while(1);
```

* 互斥的条件是满足的
* Progress 不能得到满足 ： 比方说 线程 1 进入临界区执行，退出临界区的时候，把 turn 设置为 2；但是线程 2 并不想访问临界区；这个时候如果线程 1 想再次进入临界区就不行了，因为 turn 永远是 2

## 方法2

```c++
int flag[2]; flag[0] = flag[1] = 0;
flag[i] = 1;  // 表示某一个线程想进入临界区

Thread i:
do {
    while(flag[j] == 1); // 如果另一个线程想进入临界区，那么等待另一个线程执行临界区完毕
    flag[i] = 1;
    critical section;
    flag[i] = 0;
    remainder section;
}while(1);
```

* 互斥的条件不满足，初始的情况，两个 flag 都是0，如果两个线程同时进入 do_while ，那么就出错了

```c++
int flag[2]; flag[0] = flag[1] = 0;
flag[i] = 1;  // 表示某一个线程想进入临界区

Thread i:
do {
    flag[i] = 1; // 1
    while(flag[j] == 1); // 如果另一个线程想进入临界区，那么等待另一个线程执行临界区完毕
   
    critical section;
    flag[i] = 0;
    remainder section;
}while(1);
```

* 这种方法也不行,当线程 0  完成了第1步，发生了上下文的切换，线程 1 开始执行，这个时候就造成了两个线程都在 while 中进行等待（死锁）

## 方法 3 ： Piterson 算法

```c++
int turn; // 指示谁进入临界区
bool flag[]; // 指示进程是否准备好进入临界区

Thread i :
do {
	flag[i] = TRUE;
	turn  = j;
	while(flag[j] && turn == j);
    	critical section;
    flag[i] = FALSE;
    	remainder section;
}while(1)
```

* 互斥满足
* 有限等待也满足

