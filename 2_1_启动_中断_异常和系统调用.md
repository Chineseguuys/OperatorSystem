# 启动 中断 异常 系统调用

## 启动

> 启动的三大部分：CPU,Memory, IO

DISK : 存放系统

BIOS ： 基本 I/O 处理系统

* 负责上电之后的外设的检测

BootLoader : 加载 OS

步骤：

1. POST（加电自检）：寻找显卡和执行 BIOS
2. BIOS 将 BootLoader 加载到内存当中去。BootLoaber 一般放在我们硬盘的第一个主引导扇区
3. BootLoader 将操作系统的代码和数据从硬盘加载到内存
4. 计算机被操作系统掌控

## 系统调用 异常 中断

* 系统调用（来源于应用程序）
  * 应用程序主动向操作系统发出服务
* 异常（来源于不良的应用程序）
  * 非法值令或者去它坏的处理状态
* 中断（来源于外设）
  * 来自于不同的硬件设备的计时器和网络的中断

> 在计算机中，内核是被信任的软件

> 只有操作系统可以执行特权值令

> 为了方便应用程序（屏蔽底层的复杂性，提供高层的抽象）



源头：

* 中断：外设
* 异常：应用程序意想不到的行为
* 系统调用：应用程序请求操作系统提供服务

处理事件：

* 中断：异步
* 异常：同步
* 系统调用：异步或者同步

响应：

* 中断：持续，对应用程序是透明的
* 异常：杀死或者重新执行意想不到的应用程序值令
* 系统调用：等待和持续

## 中断和异常的处理机制

* 中断是外设的事件
* 异常是内部 CPU 的事件
* 中断和异常迫使 CPU 访问一些被中断和异常服务访问的功能

### 中断发生，硬件需要进行的操作

1. 将内部，外部的事件设置中断标记
   * 外设发出的中断，发送给CPU(可能是直接的方式或者间接的方式)。CPU 根据外设的中断信息生成相应的中断号，发送给我们的操作系统。从而使得我们的操作系统可以根据中断号在（中断表）中查找到相应的中断服务程序的地址。
2. 中断事件的 ID

> 中断事件的 ID 指的是程序访问的中断向量的地址

* 首先在产生了一个中断或者异常之后，我们首先需要知道是谁产生了中断或者异常。所以我们需要建立一张表，这种表的一侧(key) 是我们的中断号或者异常号，另一端是一个地址，这个地址是针对特定的中断的中断服务程序的地址。这样当我们的操作系统收到了一个中断，我们可以根据中断号快速的找到相应的中断的服务程序的地址，直接转到相应的地址去执行相应的中断服务程序
* 当我们的中断发生的时候，打断了我们当前正在正常执行的程序，所以我们的操作系统还需要做更多的事情。我们的操作系统需要对当前运行的程序进行保存（包括CPU寄存器中的内容，...） 可以保证操作系统在执行完中断服务程序之后可以继续正常的执行被打断的程序

### 中断发生，软件需要进行的操作

1. 保存当前的处理状态
   * 当前的程序执行到什么地方了；当前 CPU 相关的寄存器中的内容是什么都需要进行保存

2. 操作系统根据中断号找到相应的中断服务程序的地址，跳到相应的程序进行中断处理
3. 清除中断标记
4. 恢复之前保存的处理状态
   * 应用程序可以完全不会感知到中断的发生

### 异常

> 异常是我们的应用程序执行到了某一条特定的值令的时候，这个值令触发了一个异常的事件(比如除 0 的操作)。每一个异常事件都有自己的一个异常编号（异常ID 号）

#### 异常编号

* 保存现场
* 异常处理
  * 杀死发生异常的程序
  * 重新执行异常值令
* 恢复现场

## 系统调用

> 应用程序需要我们的操作系统提供服务，这些服务不能由我们的用户程序直接来执行，需要我们的操作系统来执行（将执行的结果反馈给我们）。那么操作系统和我们的应用程序之间就有一层接口，这个接口就被称之为系统调用

* 程序的访问往往是使用更高层的 API 接口而不是直接使用系统调用来完成的
* Win32 API 用于 windows
* POSIX API 用于POSIX-based systems(包括 unix, linux, Mac OS  X 的所有版本)
* Java API 用于 java 虚拟机(JVM)

### 系统调用还需要了解

* 通常情况下，与每个系统调用有相关的序号
  * 系统调用接口根据这些序号来维护表的索引
* **系统调用接口** 调用内核态中预期的系统调用
  * 并返回系统调用的状态和其他可能任何类型的返回值
* 用户不需要知道系统调用是如何实现的
  * 只需要获取 API 和了解操作系统将什么内容作为返回值
  * 操作系统接口的细节大部分都隐藏在 API 当中
    * 通过运行程序支持的库来进行管理（用包含编译器的库来创建函数集）

### 用户态和内核态

1. 用户态

用户态指的是我们的应用程序在执行的过程中，CPU 所处在非特权执行的状态。它的特点就是权限特别的低，不能执行某些特定的机器指令，也不能直接访问 IO

2. 内核态

操作系统在运行过程中，CPU 所处在的一个特权执行的状态。在这种状态下，我们的操作系统可以执行任意的值令（包括特权值令，访问IO），对整个计算机拥有完全的控制权

3. 用户态 $\Longleftrightarrow$ 内核态

当我们使用系统调用的时候，我们的操作系统需要完成一个特殊的转换--从用户态到内核态的转换。从而使得控制权从应用程序转换到操作系统。

### 系统调用和函数调用的区别

1. 函数调用

当我们的应用程序发出了一个函数调用的时候，实际上是在应用程序的栈空间完成了函数的参数的传递，参数的返回

2. 系统调用

在进行系统调用的时候，我们的应用程序和我们的操作系统是拥有各自的堆栈，所以当我们的应用程序使用系统调用的时候，完成从用户态到内核态的转化的时候，我们的操作系统需要切换堆栈。堆栈的切换和从用户态到内核态的转换都需要一定的开销。所以执行系统调用的时候，开销往往比执行函数调用要大

## 跨越操作系统边界的开销

* 在执行时间上的开销超过了程序调用
* 开销：
  * 建立中断/异常/系统调用号与对应的服务
  * 建立内核堆栈
  * 验证参数
  * 内核态映射到用户态的地址空间
    * 更新页面映射权限
  * 内核态独立地址空间
    * TLB

