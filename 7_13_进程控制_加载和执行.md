# 进程控制---- 进程的加载和执行

## 系统调用 exec() 加载程序取代当前运行的程序

```c++
int main(int argc, char** argv)
{
	/**
	 * Do something
	*/
	pid_t pid = fork();
	if (pid_t == 0)
	{
        // 子进程在这里继续
		int exec_status = exec("calc", argc, argv[0], argv[1],....);
		printf(".....")
	}
	else if (pid_t > 0)
	{
        // 父进程在这里继续
		// ....
	}
	else 
	{
        //发生了错误
		// ....
	}
}
```

* exec() 调用允许一个进程加载一个不同的程序并且在 main 开始执行(事实上从 _start)
* 它允许一个进程指定参数的数量（argc） 和它字符串参数数组 (argv) 
* 如果调用成功
  * 它是相同的进程
  * 但是它运行了一个不同的程序
* 代码，stack(栈), heap(堆) 重写



1. fork() 的简单实现：
   * 对子进程分配内存
   * 赋值父进程的内存和 CPU 寄存器到子进程里面
   * 开销昂贵
2. 在 99% 的情况下，我们在调用 fork() 之后调用 exec()
   * 在 fork() 操作中内存复制是没有用的
   * 子进程将可能关闭打开的文件和连接
   * 开销因此是高的
3. vfork()
   * 一个创建进程的系统调用，不需要创建一个同样的内存映像
   * 一些时候称之为轻量级 fork()
   * 子进程应该几乎立即调用 exec()
   * 现在不再使用，我们使用 Copy on Write （COW） 机制

